# Импорт библиотеки для работы с процессами и системной информацией
# psutil позволяет получать информацию о процессах, использовании CPU, памяти и т.д.
import psutil

# Импорт библиотеки для работы со временем (используется для пауз в мониторинге)
import time

# Импорт модуля для создания абстрактных базовых классов
# ABC - Abstract Base Class, abstractmethod - декоратор для абстрактных методов
from abc import ABC, abstractmethod

# Импорт декоратора для автоматического создания методов __init__, __repr__ и других
# Упрощает создание классов, которые в основном хранят данные
from dataclasses import dataclass

# Импорт типов для аннотаций (указания типов переменных и возвращаемых значений)
# List - тип для списков, Generator - тип для генераторов
from typing import List, Generator

# Импорт модуля для работы с декораторами
# wraps используется для сохранения метаданных декорируемой функции
from functools import wraps

# Определение декоратора для создания форматированных заголовков
# Декоратор принимает заголовок в качестве параметра
def header_decorator(title: str):
    # Внутренняя функция-декоратор, которая принимает функцию для декорирования
    def decorator(func):
        # Используем wraps для сохранения имени и документации оригинальной функции
        @wraps(func)
        # Обертка, которая будет вызываться вместо оригинальной функции
        def wrapper(*args, **kwargs):
            # Печатаем пустую строку для отделения от предыдущего вывода
            print("\n" + "=" * 50)
            # Центрируем заголовок в строке шириной 50 символов
            print(title.center(50))
            # Печатаем нижнюю границу заголовка
            print("=" * 50)
            # Вызываем оригинальную функцию и возвращаем её результат
            return func(*args, **kwargs)
        # Возвращаем обертку
        return wrapper
    # Возвращаем декоратор
    return decorator

# Создаем класс для хранения информации о процессе
# @dataclass(order=True) автоматически генерирует:
# - __init__ для инициализации
# - __repr__ для строкового представления
# - методы сравнения (__lt__, __gt__ и др.) благодаря order=True
@dataclass(order=True)
class ProcessInfo:
    # Поле для хранения идентификатора процесса (целое число)
    pid: int
    
    # Поле для хранения имени процесса (строка)
    name: str
    
    # Поле для хранения процента использования CPU (число с плавающей точкой)
    cpu_percent: float
    
    # Поле для хранения процента использования памяти (число с плавающей точкой)
    memory_percent: float
    
    # Определяем метод для преобразования объекта в строку
    # Используется при печати объекта
    def __str__(self):
        # Форматируем вывод с фиксированной шириной колонок:
        # - PID: 8 символов, выравнивание по левому краю
        # - Имя: максимум 20 символов, выравнивание по левому краю
        # - CPU%: 8 символов, 1 знак после точки
        # - Память%: 10 символов, 2 знака после точки
        return f"{self.pid:<8} {self.name[:20]:<20} {self.cpu_percent:<8.1f} {self.memory_percent:<10.2f}"

# Класс-итератор для перебора процессов
# Итератор позволяет использовать объект в цикле for
class ProcessIterator:
    # Метод, который вызывается при создании итератора
    # Возвращает сам объект с инициализированными атрибутами
    def __iter__(self):
        # Создаем пустой список для хранения информации о процессах
        self.processes = []
        
        # Проходим по всем процессам в системе
        # psutil.process_iter() возвращает итератор по процессам
        # Параметр ['pid', 'name', 'cpu_percent', 'memory_percent'] указывает,
        # какие атрибуты процесса нужно получить
        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
            # Обрабатываем возможные исключения при доступе к процессу
            try:
                # Получаем словарь с информацией о процессе
                info = proc.info
                
                # Создаем объект ProcessInfo и добавляем его в список
                self.processes.append(ProcessInfo(
                    pid=info['pid'],  # Идентификатор процесса
                    name=info['name'],  # Имя процесса
                    # Если cpu_percent равен None, используем 0.0
                    cpu_percent=info['cpu_percent'] or 0.0,
                    # Если memory_percent равен None, используем 0.0
                    memory_percent=info['memory_percent'] or 0.0
                ))
            except:
                # Если произошла ошибка (например, нет прав доступа к процессу),
                # пропускаем этот процесс и продолжаем цикл
                continue
        
        # Инициализируем индекс для отслеживания текущей позиции в списке
        self.index = 0
        
        # Возвращаем сам объект как итератор
        return self
    
    # Метод для получения следующего элемента итератора
    def __next__(self):
        # Проверяем, не достигли ли мы конца списка
        if self.index < len(self.processes):
            # Получаем процесс по текущему индексу
            process = self.processes[self.index]
            # Увеличиваем индекс для следующего вызова
            self.index += 1
            # Возвращаем процесс
            return process
        # Если достигли конца списка, вызываем исключение StopIteration
        # Это сигнализирует Python о завершении итерации
        raise StopIteration

# Функция-генератор для получения информации о процессах
# Генератор отличается от итератора тем, что использует yield
# и сохраняет свое состояние между вызовами
def process_generator():
    # Проходим по всем процессам в системе
    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
        try:
            # Получаем информацию о процессе
            info = proc.info
            
            # Используем yield для возврата значения без завершения функции
            # При следующем вызове функция продолжит с этого места
            yield ProcessInfo(
                pid=info['pid'],
                name=info['name'],
                cpu_percent=info['cpu_percent'] or 0.0,
                memory_percent=info['memory_percent'] or 0.0
            )
        except:
            # Если произошла ошибка, пропускаем этот процесс
            continue

# Абстрактный базовый класс для интерфейса завершения процессов
# Наследование от ABC указывает, что это абстрактный класс
class ProcessInterface(ABC):
    # Декоратор @abstractmethod указывает, что метод должен быть реализован
    # в дочерних классах
    @abstractmethod
    def terminate(self) -> bool:
        # Абстрактный метод не имеет реализации
        # Его должны реализовать конкретные классы
        pass

# Конкретный класс для завершения процессов
# Наследуется от ProcessInterface, поэтому должен реализовать метод terminate()
class ProcessTerminator(ProcessInterface):
    # Конструктор класса, принимает PID процесса для завершения
    def __init__(self, pid: int):
        # Сохраняем PID как атрибут объекта
        self.pid = pid
        
        try:
            # Пытаемся создать объект psutil.Process по PID
            # psutil.Process предоставляет методы для управления процессом
            self.proc = psutil.Process(pid)
        except:
            # Если процесс не найден или произошла ошибка, устанавливаем None
            self.proc = None
    
    # Реализация абстрактного метода terminate()
    def terminate(self) -> bool:
        # Проверяем, был ли успешно создан объект процесса
        if not self.proc:
            # Если нет, возвращаем False (не удалось завершить)
            return False
        
        try:
            # Пытаемся мягко завершить процесс (посылаем SIGTERM на Unix или закрываем на Windows)
            self.proc.terminate()
            # Ждем завершения процесса (максимум 2 секунды)
            self.proc.wait(timeout=2)
            # Если успешно, возвращаем True
            return True
        except:
            # Если мягкое завершение не сработало, пытаемся принудительно завершить
            try:
                # Принудительное завершение (посылаем SIGKILL на Unix или убиваем на Windows)
                self.proc.kill()
                # Возвращаем True при успешном завершении
                return True
            except:
                # Если и принудительное завершение не сработало, возвращаем False
                return False

# Функция для сортировки процессов по использованию памяти
# Используется как ключ для метода sort()
def sort_by_memory(proc):
    # Возвращает значение memory_percent для сравнения при сортировке
    return proc.memory_percent

# Функция для сортировки процессов по использованию CPU
# Используется как ключ для метода sort()
def sort_by_cpu(proc):
    # Возвращает значение cpu_percent для сравнения при сортировке
    return proc.cpu_percent

# Основной класс для управления процессами
class ProcessManager:
    # Конструктор класса, не принимает параметров
    def __init__(self):
        # Просто заглушка, можно было бы использовать pass
        pass
    
    # Метод для отображения всех процессов
    # Декоратор @header_decorator добавляет форматированный заголовок
    @header_decorator("ВСЕ ПРОЦЕССЫ")
    def show_all_processes(self):
        # Создаем пустой список для хранения процессов
        processes = []
        
        # Счетчик для подсчета общего количества процессов
        count = 0
        
        # Используем генератор для получения информации о каждом процессе
        for proc in process_generator():
            # Добавляем процесс в список
            processes.append(proc)
            # Увеличиваем счетчик
            count += 1
        
        # Сортируем процессы по использованию памяти в обратном порядке (от большего к меньшему)
        processes.sort(key=sort_by_memory, reverse=True)
        
        # Выводим заголовок таблицы
        # Используем форматирование с фиксированной шириной колонок
        print(f"{'PID':<8} {'Имя':<20} {'CPU%':<8} {'Память%':<10}")
        # Выводим разделительную линию
        print("-" * 50)
        
        # Выводим топ-50 процессов (или все, если их меньше 50)
        # Используем срез списка [:50] для получения первых 50 элементов
        for proc in processes[:50]:
            # Печатаем информацию о процессе
            # Метод __str__ класса ProcessInfo вызывается автоматически
            print(proc)
        
        # Выводим общее количество процессов
        print(f"\nВсего процессов: {count}")
    
    # Метод для завершения процесса
    # Декоратор @header_decorator добавляет форматированный заголовок
    @header_decorator("ЗАВЕРШЕНИЕ ПРОЦЕССА")
    def kill_process(self):
        # Запрашиваем у пользователя идентификатор процесса
        # strip() удаляет пробелы в начале и конце строки
        identifier = input("Введите PID или имя процесса: ").strip()
        
        # Проверяем, является ли введенная строка числом
        if identifier.isdigit():
            # Преобразуем строку в целое число
            pid = int(identifier)
            
            # Создаем объект ProcessTerminator для этого PID
            terminator = ProcessTerminator(pid)
            
            # Пытаемся завершить процесс
            if terminator.terminate():
                # Если успешно, выводим сообщение
                print(f"Процесс {pid} завершен")
            else:
                # Если не удалось, выводим сообщение об ошибке
                print(f"Не удалось завершить процесс {pid}")
        else:
            # Если введено не число, считаем что это имя процесса
            # Вызываем вспомогательный метод для завершения по имени
            self._kill_by_name(identifier)
    
    # Вспомогательный метод для завершения процессов по имени
    # Начинается с подчеркивания, что указывает на "приватность" метода
    # (хотя в Python нет настоящих приватных методов)
    def _kill_by_name(self, name: str):
        # Создаем пустой список для хранения найденных процессов
        found = []
        
        # Проходим по всем процессам в системе
        # Запрашиваем только pid и name для оптимизации
        for proc in psutil.process_iter(['pid', 'name']):
            try:
                # Проверяем, содержится ли введенное имя в имени процесса
                # Используем lower() для регистронезависимого поиска
                if name.lower() in proc.info['name'].lower():
                    # Если нашли совпадение, добавляем информацию о процессе в список
                    found.append(proc.info)
            except:
                # Если произошла ошибка, пропускаем процесс
                continue
        
        # Проверяем, найдены ли процессы
        if not found:
            # Если не найдено, выводим сообщение
            print(f"Процессы с именем '{name}' не найдены")
            # Выходим из метода
            return
        
        # Выводим количество найденных процессов
        print(f"\nНайдено процессов: {len(found)}")
        
        # Перечисляем найденные процессы с номерами
        # enumerate(found, 1) возвращает пары (номер, элемент) начиная с 1
        for i, p in enumerate(found, 1):
            # Выводим номер, PID и имя процесса
            print(f"{i}. PID: {p['pid']}, Имя: {p['name']}")
        
        # Если найден только один процесс
        if len(found) == 1:
            # Автоматически выбираем его
            choice = 1
        else:
            # Если процессов несколько, запрашиваем выбор у пользователя
            try:
                # Преобразуем ввод в целое число
                choice = int(input(f"\nВыберите процесс (1-{len(found)}): "))
                
                # Проверяем, находится ли выбор в допустимом диапазоне
                if not 1 <= choice <= len(found):
                    # Если нет, выводим сообщение и выходим
                    print("Неверный выбор")
                    return
            except:
                # Если ввод не является числом, выводим сообщение и выходим
                print("Введите число")
                return
        
        # Получаем PID выбранного процесса
        # choice-1 потому что список индексируется с 0, а номера выводились с 1
        pid = found[choice-1]['pid']
        
        # Создаем объект ProcessTerminator для выбранного PID
        terminator = ProcessTerminator(pid)
        
        # Пытаемся завершить процесс
        if terminator.terminate():
            # Если успешно, выводим сообщение
            print(f"Процесс {pid} завершен")
        else:
            # Если не удалось, выводим сообщение об ошибке
            print(f"Не удалось завершить процесс {pid}")
    
    # Метод для мониторинга ресурсов
    # Декоратор @header_decorator добавляет форматированный заголовок
    @header_decorator("МОНИТОРИНГ РЕСУРСОВ")
    def monitor_resources(self):
        # Выводим варианты мониторинга
        print("1. Мониторинг всех процессов (топ по CPU)")
        print("2. Мониторинг конкретного процесса")
        
        # Запрашиваем выбор пользователя
        choice = input("Выбор (1-2): ").strip()
        
        # Обрабатываем выбор
        if choice == "1":
            # Если выбран мониторинг всех процессов
            self._monitor_all()
        elif choice == "2":
            # Если выбран мониторинг конкретного процесса
            self._monitor_specific()
        else:
            # Если введен неверный выбор
            print("Неверный выбор")
    
    # Вспомогательный метод для мониторинга всех процессов
    def _monitor_all(self):
        # Выводим описание функции
        print("\nМониторинг топ-5 процессов по CPU (5 секунд)")
        
        # Выводим заголовок таблицы
        print(f"{'Время':<8} {'PID':<8} {'Имя':<15} {'CPU%':<8} {'Память%':<10}")
        print("-" * 60)
        
        # Мониторим в течение 5 секунд
        # range(5) создает последовательность [0, 1, 2, 3, 4]
        for second in range(5):
            # Создаем пустой список для текущих процессов
            processes = []
            
            # Собираем информацию о всех текущих процессах
            for proc in process_generator():
                processes.append(proc)
            
            # Сортируем процессы по использованию CPU в обратном порядке
            processes.sort(key=sort_by_cpu, reverse=True)
            
            # Выводим номер текущей секунды
            print(f"\n{second+1} сек:")
            
            # Выводим топ-5 процессов (или меньше, если процессов меньше 5)
            # min(5, len(processes)) гарантирует, что не выйдем за границы списка
            for i in range(min(5, len(processes))):
                # Получаем i-й процесс
                p = processes[i]
                # Выводим информацию о процессе
                print(f"{'':<8} {p.pid:<8} {p.name[:15]:<15} {p.cpu_percent:<8.1f} {p.memory_percent:<10.2f}")
            
            # Если это не последняя итерация (second < 4), делаем паузу
            if second < 4:
                # Ждем 1 секунду перед следующим измерением
                time.sleep(1)
    
    # Вспомогательный метод для мониторинга конкретного процесса
    def _monitor_specific(self):
        try:
            # Запрашиваем PID процесса у пользователя
            # Преобразуем ввод в целое число
            pid = int(input("\nВведите PID процесса: ").strip())
            
            # Выводим заголовок мониторинга
            print(f"\nМониторинг процесса {pid} (10 секунд)")
            
            # Выводим заголовок таблицы
            print(f"{'Время':<8} {'CPU%':<8} {'Память%':<10} {'Память (MB)':<12}")
            print("-" * 60)
            
            # Мониторим в течение 10 секунд
            for i in range(10):
                try:
                    # Создаем объект процесса по PID
                    proc = psutil.Process(pid)
                    
                    # Получаем процент использования CPU за последнюю секунду
                    # interval=1 означает, что метод будет ждать 1 секунду для измерения
                    cpu = proc.cpu_percent(interval=1)
                    
                    # Получаем процент использования памяти
                    mem_percent = proc.memory_percent()
                    
                    # Получаем использование памяти в байтах и преобразуем в мегабайты
                    # memory_info().rss возвращает Resident Set Size (фактическую память в ОЗУ)
                    # // - целочисленное деление
                    mem_mb = proc.memory_info().rss // (1024 * 1024)
                    
                    # Выводим информацию о процессе
                    print(f"{i+1} сек:{'':<4} {cpu:<8.1f} {mem_percent:<10.2f} {mem_mb:<12}")
                    
                except psutil.NoSuchProcess:
                    # Исключение возникает, если процесс не найден (завершился)
                    print(f"\nПроцесс {pid} завершен")
                    # Прерываем цикл мониторинга
                    break
                    
                except:
                    # Если произошла другая ошибка
                    print(f"\nОшибка мониторинга")
                    # Прерываем цикл мониторинга
                    break
                    
        except ValueError:
            # Исключение возникает, если ввод не может быть преобразован в число
            print("PID должен быть числом")

# Главная функция программы
# Точка входа при запуске скрипта напрямую
def main():
    # Создаем объект ProcessManager
    manager = ProcessManager()
    
    # Бесконечный цикл для работы с меню
    # while True будет выполняться до явного выхода
    while True:
        # Выводим главное меню
        print("\n" + "=" * 50)
        print("УПРАВЛЕНИЕ ПРОЦЕССАМИ")
        print("=" * 50)
        print("1. Показать все процессы")
        print("2. Завершить процесс")
        print("3. Мониторинг ресурсов")
        print("4. Выход")
        
        # Запрашиваем выбор пользователя
        choice = input("\nВыбор (1-4): ").strip()
        
        # Обрабатываем выбор пользователя
        if choice == "1":
            # Показываем все процессы
            manager.show_all_processes()
        elif choice == "2":
            # Завершаем процесс
            manager.kill_process()
        elif choice == "3":
            # Мониторим ресурсы
            manager.monitor_resources()
        elif choice == "4":
            # Выходим из программы
            print("\nВыход из программы")
            # break прерывает цикл while
            break
        else:
            # Если введен неверный выбор
            print("\nНеверный выбор")
        
        # Делаем небольшую паузу для удобства чтения вывода
        time.sleep(0.5)

# Проверка, запущен ли скрипт напрямую (а не импортирован как модуль)
if __name__ == "__main__":
    # Если скрипт запущен напрямую, вызываем main()
    main()